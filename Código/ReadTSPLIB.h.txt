#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sstream>
#include <assert.h>
#include <limits>
#include <iostream>
#include <math.h>

using namespace std;

typedef struct scity {
    float longitude;
    float latitude;
    float profundidade;
} city;

int cid;
city* cities;
float* distancias;
char edge_weight_type[32];

void setDistancias();
int setCities(const char* filename, float r, int c);
void setIndOtimo(const char* filename, int* opt);

int encerra(string str){
    return -1;
}

/*
Cria as cidades dispostas em círculo, e atribui a distância 
entre elas ao vetor distancias.
*/
void geraCidades(float raio, int c){
    float deltaAlfa=0.0f, alfa=0.0f;
    int i=0;
    cid = c;
    deltaAlfa = 2*M_PI/cid;
    cities = (city*)malloc(cid*sizeof(city));
    assert (cities);
    char str[7] = "EUC_2D";
    for(i=0; i<7; i++){
        edge_weight_type[i] = str[i];
    }
    for(i=0; i<cid; i++){
        alfa = i*deltaAlfa;
        cities[i].longitude = raio*cos(alfa);
        cities[i].latitude = raio*sin(alfa);
    }
    setDistancias();
}

/*
Recebe o nome do arquivo em formato .tsp, o raio e número de cidades.
Para execução TSPLIB os parâmetros raio e número de cidades são 
desnecessários, portanto, qualquer valor pode ser passado.
Estes parâmetros somente são usados para gerar cidades em círculo.
Retorna 0 e chama setDistancias caso haja sucesso
*/
int setCities(const char* filename, float r, int c){
    int i1=0;
    FILE *f;
    ostringstream ostr;
    char str[256];
    f = fopen(filename, "r");
    if (f == NULL) {
	geraCidades(r, c);
        return 1;
    }

	do{
		fscanf(f, "%s", str);
		if(strcmp(str, "TYPE:") == 0 || strcmp(str, "TYPE :") == 0){
			fscanf(f, "%s", str);
			if(strcmp(str, "TSP") != 0){
                ostr << "Tipo " << str << " ainda nao e suportado!";
                return encerra(ostr.str());
			}
		}else if(string::npos != ((string)str).find("DIMENSION")){
            fscanf(f, "%d\n", &cid);
            //if(strcmp(edge_weight_type, ":")==0) fscanf(f, "%s\n", edge_weight_type);
		}else if(string::npos != ((string)str).find("EDGE_WEIGHT_TYPE")){
			fscanf(f, "%s\n", edge_weight_type);
			if(strcmp(edge_weight_type, ":")==0) fscanf(f, "%s\n", edge_weight_type);
		}else if (string::npos != ((string)str).find("EOF")) {
            return encerra("arquivo em formato incorreto");
    	}
	}while(strcmp(str, "NODE_COORD_SECTION") != 0);   
	
    cities = (city*)malloc(cid*sizeof(city));
    assert (cities);

	if(strcmp(edge_weight_type, "EUC_2D") == 0 || strcmp(edge_weight_type, "MAX_2D") == 0 || strcmp(edge_weight_type, "MAN_2D") == 0 || strcmp(edge_weight_type, "CEIL_2D") == 0 || strcmp(edge_weight_type, "ATT") == 0){
        while (i1 < cid){
        	fscanf(f, "%s", str);
        	i1 = atoi(str);
        	fscanf(f, "%s", str);
        	cities[i1-1].longitude = atof(str);
        	fscanf(f, "%s", str);
        	cities[i1-1].latitude = atof(str);
    	}
	}else if(strcmp(edge_weight_type, "EUC_3D") == 0 || strcmp(edge_weight_type, "MAX_3D") == 0 || strcmp(edge_weight_type, "MAN_3D") == 0){
        while (i1 < cid){
        	fscanf(f, "%s", str);
        	i1 = atoi(str);
        	fscanf(f, "%s", str);
        	cities[i1-1].longitude = atof(str);
        	fscanf(f, "%s", str);
        	cities[i1-1].latitude = atof(str);
			fscanf(f, "%s", str);
        	cities[i1-1].profundidade = atof(str);
    	}
	}else if(strcmp(edge_weight_type, "GEO") == 0){
		float x=0.0f, y=0.0f, min=0.0f;
		int deg=0;
        while (i1 < cid){
        	fscanf(f, "%s", str);
        	i1 = atoi(str);
        	fscanf(f, "%s", str);
			x = atof(str);
			deg = (int)x;
			min = x - deg;
			cities[i1-1].latitude = M_PI * (deg + 5.0f * min / 3.0f ) / 180.0f;
			fscanf(f, "%s", str);
        	y = atof(str);
			deg = (int)y;
			min = y - deg;
			cities[i1-1].longitude = M_PI * (deg + 5.0f * min / 3.0f ) / 180.0f;
    	}
	}else if(strcmp(edge_weight_type, "EXPLICIT") == 0){
        return encerra("arquivo TSPLIB em formato EXPLICIT, ainda, não suportado!");
	}else if(strcmp(edge_weight_type, "XRAY1") == 0){
        return encerra("arquivo TSPLIB em formato XRAY1, ainda, não suportado!");
	}else if(strcmp(edge_weight_type, "XRAY2") == 0){
        return encerra("arquivo TSPLIB em formato XRAY2, ainda, não suportado!");
	}else if(strcmp(edge_weight_type, "SPECIAL") == 0){
        return encerra("arquivo TSPLIB em formato SPECIAL, ainda, não suportado!");
	}else{
        return encerra("arquivo TSPLIB em formato incorreto!");
	}

    fscanf(f, "%s", str);
    if (strcmp(str, "EOF") != 0 && strcmp(str, "-1") != 0) {
        encerra("'EOF' não encontrado");
    }
    fclose(f);
    setDistancias();
    return 0;
}

/*
Adiciona no vetor distancias o custo de movimentação entre cada cidade.
A leitura pode ser feita linha x coluna ou coluna x linha, uma vez 
que os trajetos são simétricos e possuem mesmo peso na ida e volta.
*/
void setDistancias(){
    int i=0, j=0;
    distancias = (float*)malloc(cid*cid*sizeof(float));
    if(strcmp(edge_weight_type, "EUC_2D") == 0){
        for(i=0; i<cid; i++){
      	  	for(j=0; j<cid; j++){
        	    distancias[i*cid + j] = sqrt(pow(cities[i].longitude - cities[j].longitude, 2.0f) + pow(cities[i].latitude - cities[j].latitude, 2.0f));
        	}
    	}
	}else if(strcmp(edge_weight_type, "MAX_2D") == 0){
        int xd=0, yd=0;
		for(i=0; i<cid; i++){
      	  	for(j=0; j<cid; j++){
                xd = abs(cities[i].longitude - cities[j].longitude);
                yd = abs(cities[i].latitude -cities[j].latitude);
        	    distancias[i*cid + j] = max( xd, yd );
        	}
    	}
	}else if(strcmp(edge_weight_type, "MAN_2D") == 0){
		float xd=0.0f, yd=0.0f;		
		for(i=0; i<cid; i++){
      	  for(j=0; j<cid; j++){
                xd = abs(cities[i].longitude - cities[j].longitude);
                yd = abs(cities[i].latitude -cities[j].latitude);
				distancias[i*cid + j] = (int)( xd + yd );
        	}
    	}
	}else if(strcmp(edge_weight_type, "CEIL_2D") == 0){
		for(i=0; i<cid; i++){
      	  	for(j=0; j<cid; j++){
        	    distancias[i*cid + j] = ceil(sqrt(pow(cities[i].longitude - cities[j].longitude, 2.0f) + pow(cities[i].latitude - cities[j].latitude, 2.0f)));
        	}
    	}
	}else if(strcmp(edge_weight_type, "EUC_3D") == 0){
		for(i=0; i<cid; i++){
      	  	for(j=0; j<cid; j++){
        	    distancias[i*cid + j] = sqrt(pow(cities[i].longitude - cities[j].longitude, 2.0f) + pow(cities[i].latitude - cities[j].latitude, 2.0f) + pow(cities[i].profundidade - cities[j].profundidade, 2.0f));
			}
    	}
	}else if(strcmp(edge_weight_type, "MAX_3D") == 0){
		float xd=0.0f, yd=0.0f, zd=0.0f;		
		for(i=0; i<cid; i++){
      	  for(j=0; j<cid; j++){
                xd = abs(cities[i].longitude - cities[j].longitude);
                yd = abs(cities[i].latitude -cities[j].latitude);
                zd = abs(cities[i].profundidade -cities[j].profundidade);
        	    distancias[i*cid + j] = max( max(xd, yd), zd );
        	}
    	}
	}else if(strcmp(edge_weight_type, "MAN_3D") == 0){
		float xd=0.0f, yd=0.0f, zd=0.0f;		
		for(i=0; i<cid; i++){
      	  for(j=0; j<cid; j++){
                xd = abs(cities[i].longitude - cities[j].longitude);
                yd = abs(cities[i].latitude -cities[j].latitude);
                zd = abs(cities[i].profundidade -cities[j].profundidade);
        	    distancias[i*cid + j] = (int)( xd + yd + zd );
        	}
    	}
	}else if(strcmp(edge_weight_type, "GEO") == 0){
		float RRR = 6378.388f, q1=0.0f, q2=0.0f, q3=0.0f;
		for(i=0; i<cid; i++){
			for(j=0; j<cid; j++){
				q1 = cos(cities[i].longitude - cities[j].longitude);
				q2 = cos(cities[i].latitude - cities[j].latitude);
				q3 = cos(cities[i].latitude + cities[j].latitude);
				distancias[i*cid + j] = floor( RRR * acos( 0.5f * ((1.0f + q1) * q2 - (1.0f - q1) * q3) ) + 1.0f);
			}
		}
		
	}else if(strcmp(edge_weight_type, "ATT") == 0){
		float xd=0.0f, yd=0.0f, rij=0.0f;
		int tij=0;		
		for(i=0; i<cid; i++){
      	  	for(j=0; j<cid; j++){
				xd = cities[i].longitude - cities[j].longitude;
				yd = cities[i].latitude - cities[j].latitude;
				rij = sqrt( pow(xd, 2.0f) + pow(yd, 2.0f) / 10.0f);
				tij = (int)rij;
				if(tij < rij)
        	    	distancias[i*cid + j] = tij + 1;
				else 
					distancias[i*cid + j] = tij;
        	}
    	}
    }else if(strcmp(edge_weight_type, "EXPLICIT") == 0){
        encerra("arquivo TSPLIB em formato EXPLICIT, ainda, não suportado!");
    }else if(strcmp(edge_weight_type, "XRAY1") == 0){
        encerra("arquivo TSPLIB em formato XRAY1, ainda, não suportado!");
    }else if(strcmp(edge_weight_type, "XRAY2") == 0){
        encerra("arquivo TSPLIB em formato XRAY2, ainda, não suportado!");
    }else if(strcmp(edge_weight_type, "SPECIAL") == 0){
        encerra("arquivo TSPLIB em formato SPECIAL, ainda, não suportado!");
    }
    
}

/*
Recebe um arquivo de trajeto ótimo (.opt.tsp) e um vetor de inteiros
no qual será inserido o trajeto ótimo descrito no arquivo
*/
void setIndOtimo(const char* filename, int* opt){
	int i1=0;
    FILE *f;
    char str[256];
    f = fopen(filename, "r");
    if (f == NULL) {
        ostringstream ostr;
        ostr << "Falha ao abrir o arquivo " << filename;
        encerra(ostr.str());
    }

	do{ fscanf(f, "%s", str); }while(strcmp(str, "TOUR_SECTION") != 0);   

	while (i1 < cid){
       	fscanf(f, "%s", str);
       	opt[i1] = atoi(str);
		i1++;
    }

	fclose(f);
}
